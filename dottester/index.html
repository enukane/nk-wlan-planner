<!DOCTYPE html>
<html lang="jp">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
</head>

<body>
    <style type="text/css" media="screen">
    </style>

    <h1>Map</h1>
    <canvas id="canvas-map" width="1324" height="840"></canvas>
    <h1>Control</h1>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2" crossorigin="anonymous"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script type="text/javascript" charset="utf-8">
        var canvas = document.getElementById("canvas-map");
        _ctx = canvas.getContext("2d");
        var backgroundImage = new Image();
        backgroundImage.src = "map.png";

        var frequency = 5120 * 1000 * 1000;
        var apPosList = [
            {x: 200, y: 250, powerdb: 20.0},
            {x: 200, y: 500, powerdb: 20.0},
            {x: 1000, y: 600, powerdb: 20.0},
            {x: 575, y: 200, powerdb: 20.0},
            {x: 1000, y: 175, powerdb: 20.0},
        ];

        /*
         * drywall: 3
         * bookchelf: 2
         * exteriorglass: 3
         * wooddoor: 6
         * marble: 6
         * brick: 10
         * concrete 12
         * elevator shaft: 30
        */
        var obstaclesList = [
            {start: {x: 24, y:318}, end: {x: 1275, y:318}, attenuation: 12, material: "wood"},
            {start: {x: 24, y:446}, end: {x: 180, y:445}, attenuation: 12, material: "wood"},
            {start: {x: 210, y:446}, end: {x: 516, y:445}, attenuation: 12, material: "wood"},
            {start: {x: 607, y:38}, end: {x: 607, y:318}, attenuation: 3, material: "wood"},
            {start: {x: 781, y:434}, end: {x: 781, y:811}, attenuation: 3, material: "wood"},
            {start: {x: 900, y:38}, end: {x: 900, y:318}, attenuation: 3, material: "wood"},
            {start: {x: 314, y:38}, end: {x: 314, y:315}, attenuation: 3, material: "wood"},
            {start: {x: 516, y:445}, end: {x: 516, y:810}, attenuation: 3, material: "wood"},
            {start: {x: 781, y:434}, end: {x: 1275, y:434}, attenuation: 3, material: "wood"},
        ];

        var selectedLengthPXOnImage = 1300;
        var selectedLengthMeter = 60;
        var px2meter = selectedLengthMeter / selectedLengthPXOnImage; // [m/px]

        var defaultAPdBPower = 17.0;

        function initMatrix(xlim, ylim) {
            var matrix = new Array(ylim);
            for (y = 0; y < ylim; y++) {
                matrix[y] = new Array(xlim);
            }
            for (y = 0; y < matrix.length; y++) {
                for (x = 0; x < matrix[y].length; x++) {
                    matrix[y][x] = null
                }
            }
            return matrix
        }

        function updateMatrixWithAP(matrix, dBPower, apAtX, apAtY, px2meter, freqHz) {
            /* calculate */
            xbox = parseInt(apAtX/5)
            ybox = parseInt(apAtY/5)
            xboxcenter = xbox * 5 + 5/2
            yboxcenter = ybox * 5 + 5/2
            matrix[ybox][xbox] = dBPower;
            matrix[parseInt(apAtY/5)][parseInt(apAtX/5)] = dBPower;

            //for (y = 0; y < matrix.length; y++) {
            //    for (x = 0; x < matrix[y].length; x++) {
            //        xPos = x * 5 + 5/2;
            //        yPos = y * 5 + 5/2;
            //        distM = Math.sqrt( Math.pow(Math.abs(xPos - xboxcenter) * px2meter, 2) + Math.pow(Math.abs(yPos - yboxcenter) * px2meter, 2))

            //        dBPowerAtXY = dBPower - calcFreeSpaceLossdB(freqHz, distM)
            //        //console.log(xPos, yPos, distM, dBPowerAtXY)
            //        if (matrix[y][x] == null || matrix[y][x] < dBPowerAtXY) {
            //            matrix[y][x] = dBPowerAtXY
            //        }

            //    }
            //}

            //iterativeUpdatedBPower(matrix, xbox, ybox, dBPower, px2meter, freqHz)
        }

        function calcRealPoint(xbox, ybox) {
            xPos = x * 5 + 5 / 2;
            yPos = y * 5 + 5 / 2;
            return [xPos, yPos];
        }

        function calcDistance(x0, y0, x1, y1, px2meter) {
            return Math.sqrt( Math.pow(Math.abs(x0 - x1) * px2meter, 2) + Math.pow(Math.abs(y0 - y1) * px2meter, 2));
        }

        function isLineCross(a, b, c, d) {
            s = (a.x - b.x) * (c.y - a.y) - (a.y - b.y) * (c.x - a.x);
            t = (a.x - b.x) * (d.y - a.y) - (a.y - b.y) * (d.x - a.x);
            if (s * t > 0) {
                return false;
            }

            s = (c.x - d.x) * (a.y - c.y) - (c.y - d.y) * (a.x - c.x);
            t = (c.x - d.x) * (b.y - c.y) - (c.y - d.y) * (b.x - c.x);
            if (s * t > 0) {
                return false;
            }
            return true;
        }

        function calcObstaclesAttenuationdB(pos, apPos, obstaclesList) {
            attdB = 0.0
            for (let idx in obstaclesList) {
                obstacle = obstaclesList[idx];
                if (isLineCross(pos, apPos, obstacle.start, obstacle.end)) {
                    attdB += obstacle.attenuation
                }
            }
            return attdB;
        }

        function updateMatrix(matrix, apPosList, obstaclesList, px2meter, frequency) {
            for (y = 0; y < matrix.length; y++) {
                for (x = 0; x < matrix[y].length; x++) {
                    curPos = calcRealPoint(x, y)

                    for (ap_idx in apPosList) {
                        apPos = [apPosList[ap_idx].x, apPosList[ap_idx].y]
                        /* detect crossing obstacles */
                        obstaclesAttenuationdB = calcObstaclesAttenuationdB(
                            {x: curPos[0], y: curPos[1]},
                            {x: apPos[0], y: apPos[1]},
                            obstaclesList
                        )

                        distM = calcDistance(curPos[0], curPos[1], apPos[0], apPos[1], px2meter)

                        dBPowerAtXY = apPosList[ap_idx].powerdb  - obstaclesAttenuationdB - calcFreeSpaceLossdB(frequency, distM);
                        if (matrix[y][x] == null || matrix[y][x] < dBPowerAtXY) {
                            //console.log(apPosList[idx].powerdb, dBPowerAtXY)
                            matrix[y][x] = dBPowerAtXY
                        }
                    }

                }
            }

        }

        function iterativeUpdatedBPower(matrix, xBox, yBox, dBPower, px2meter, freqHz) {
            console.log("updateint adjaectt (%d, %d) power=%d (current=%d)", xBox, yBox, dBPower, matrix[yBox][xBox])
            console.log(matrix[yBox][xBox], dBPower)
            if (matrix[yBox][xBox] != null) {
                if (matrix[yBox][xBox] > dBPower) {
                    console.log("already highpower: OUT");
                    return;
                }
            }

            if (dBPower < dBPowerLimit) {
                console.log("power level too low");
                return;
            }

            matrix[yBox][xBox] = dBPower;

            xyLength = 5 * px2meter
            diagonalLength = 5 * Math.sqrt(2) * px2meter;
            xydBPower = dBPower - calcFreeSpaceLossdB(freqHz, xyLength)
            nondiagonaldBPower = dBPower - calcFreeSpaceLossdB(freqHz, diagonalLength)

            for (dY = -1; dY < 2; dY++) {
                for (dX = -1; dX < 2; dX++) {
                    if (dX == 0 && dY == 0) {
                        continue
                    }
                    console.log(dX, dY, xBox, yBox)
                    if (Math.abs(dY) == Math.abs(dX)) {
                        iterativeUpdatedBPower(matrix, xBox + dX, yBox + dY, nondiagonaldBPower, px2meter, freqHz)
                    } else  {
                        iterativeUpdatedBPower(matrix, xBox + dX, yBox + dY, xydBPower, px2meter, freqHz)
                    }
                }
            }


        }

        function dbm2mw(dbm) {
            return Math.pow(10, dbm / 10)
        }

        function mw2dbm(mw) {
            return 10 * Math.log10(mw)
        }

        function calcFreeSpaceLossdB(freqHz, distM) {
            speedOfLight = 299792458; // [m / s]
            waveLength = speedOfLight / freqHz;
            dB = 20 * Math.log10(4 * Math.PI * distM / waveLength)
            //los = Math.pow((4 * Math.PI * distM) / waveLength, 2);
            return dB
        }

        var dBPowerLimit = -96;
        var dBPower2colors = [
            [-15, "red"],
            [-25, "red"],
            [-35, "orange"],
            [-45, "yellow"],
            [-50, "lime"],
            [-55, "green"],
            [-60, "teal"],
            [-65, "navy"],
            [-70, "blue"],
            [-85, "blue"],
            [-90, "navy"],
            [-96, "blue"],
        ];

        function calcColorForPower(dBPower) {
            if (dBPower == null) {
                return "none";
            }
            for (idx in dBPower2colors) {
                if (dBPower2colors[idx][0] < dBPower) {
                    return dBPower2colors[idx][1];
                }
            }

            return "none"
        }

        function drawXYinColor(xbox, ybox, color) {
            if (color == "none") {
                return;
            }
            x_0 = xbox * 5
            y_0 = ybox * 5

            _ctx.fillStyle=color
            _ctx.globalAlpha=0.5
            _ctx.fillRect(x_0, y_0, 5, 5)
            _ctx.globalAlpha=1.0
        }

        function drawMatrix(matrix) {
            //for (y in matrix) {
            for (y = 0; y < matrix.length; y++) {
                //for (x in matrix[y]) {
                for (x = 0; x < matrix[y].length; x++) {
                    dBPower = matrix[y][x];
                    color = calcColorForPower(dBPower)
                    //console.log(x, y, color)
                    drawXYinColor(x, y, color)

                }
            }

        }

        function drawObstacles(obstacles) {
            var canvas = document.getElementById("canvas-map");
            ctx = canvas.getContext("2d");
            for (idx in obstacles) {
                start = obstacles[idx].start
                end = obstacles[idx].end
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.strokeStyle = "purple"
                ctx.lineWidth=10;
                ctx.stroke();
            }

        }


        backgroundImage.onload=function() {
            _ctx.drawImage(backgroundImage, 0, 0);

            xLim = backgroundImage.width
            yLim = backgroundImage.height

            xLimBlock = parseInt(xLim / 5);
            yLimBlock = parseInt(yLim / 5)
            console.log(xLimBlock, yLimBlock);

            matrix = initMatrix(xLimBlock, yLimBlock);
            console.log("inited", matrix)

            // fill ap
            for (key in apPosList) {
                updateMatrixWithAP(matrix, defaultAPdBPower, apPosList[key].x, apPosList[key].y, px2meter, frequency)
            }
            updateMatrix(matrix, apPosList, obstaclesList, px2meter, frequency)

            drawMatrix(matrix)
            console.log("drawn", matrix);
            drawObstacles(obstaclesList);
        }

        function mapClick(e) {
            var mapOffset = $("#canvas-map").offset();
            mouseX = parseInt(e.clientX - mapOffset.left);
            mouseY = parseInt(e.clientY - mapOffset.top);
            console.log("clicked = ", mouseX, mouseY)
        }

        $("#canvas-map").click(function(e) { mapClick(e);});
    </script>
</body>

</html>